scilla_version 0 

import BoolUtils IntUtils ListUtils PairUtils


library QVote 

let zero = Uint32 0 

let i128_len = 
  fun (l : List Int128) => 
    let len = @list_length Int128 in
    len l
let s_len = 
  fun (l : List String) => 
    let len = @list_length String in
    len l

let eq_string = 
  fun(s1 : String) => 
  fun(s2 : String) =>
    builtin eq s1 s1

let eq_lr_pair =
  fun(p : Pair String String) =>
    let f = @fst String String in
    let s = @snd String String in
    let l = f p in
    let r = s p in
    eq_string l r
    
let eq_string_lists = 
  fun(ls1 : List String) => 
  fun(ls2 : List String) =>
    let zip = @list_zip String String in
    let zipped = zip ls1 ls2 in
    let all = @list_forall (Pair String String) in
    all eq_lr_pair zipped

let list_exist_string = @list_exists String 
let list_length_string = @list_length String  

let check_option_list_valid = 
	fun (option_list : List String) => 
		let l = list_length_string option_list in 
			builtin eq l zero

let check_times_valid = 
  fun(registration: BNum) => 
  fun(decision: BNum) => 
    True   (* TODO implement me please *) 

(* event codes *) 
let not_owner_code = Uint32 0

(* decision build codes *) 
let decision_already_built_code = Uint32 1
let decision_not_build_code = Uint32 2
let option_titles_invalid_code = Uint32 3
let times_invalid_code = Uint32 4
let build_decision_success_code = Uint32 5 

(* registration codes *) 
let election_started_code = Uint32 6
let zero_token_balance_code = Uint32 7
let already_registered_code = Uint32 8
let register_success_code = Uint32 9 

(* vote codes *)
let option_invalid_code = Uint32 10 
let not_registered_code = Uint32 11 
let insufficient_balance_code = Uint32 12 
let decision_ended_code = Uint32 13
let vote_success_code = Uint32 14

(* events *)
let build_decision_success_event = {_eventname: "build_decision_success"; code: build_decision_success_code}
let build_decision_failure_event =
  fun(event_code: Uint32) => 
    {_eventname: "build_decision_failure"; code: event_code}
    
let register_success_event = {_eventname: "register_success"; code: register_success_code}
let register_failure_event = 
  fun(event_code: Uint32) => 
    {_eventname: "register_failure"; code: event_code}

let vote_success_event = {_eventname: "vote_success"; code: vote_success_code}
let vote_failure_event = 
  fun(event_code: Uint32) => 
    {_eventname: "vote_failure"; code: event_code}
    


contract QVote 
(
    owner: ByStr20,
    expiration_block: BNum, (* We are going to calculate the block at which the contract expires *)
    name: String,
    description: String,
    options: List String,
    token_to_credit_ratio: Int32,
    registration_end_time: BNum
)

(* TODO do constraint checks at contract creation *)

field voter_balances : Map ByStr20 Int32 = Emp ByStr20 Int32

(* transition build_decision(option_titles_:List String, registration_end_time_:BNum, decision_end_time_:BNum)
  decision_built_ <- decision_built; 
	match decision_built_ with 
	| True => 
		e = build_decision_failure_event decision_already_built_code;
		event e
	| False => 
		is_owner = builtin eq owner _sender; 
		match is_owner with 
		| False => 
			e = build_decision_failure_event not_owner_code;
			event e 
		| True => 	
			is_valid = check_option_list_valid option_titles_; 
			match is_valid with 
			| False => 
				e = build_decision_failure_event option_titles_invalid_code; 
				event e
			| True => 
				option_titles := option_titles_; 
				valid_times = check_times_valid registration_end_time_ decision_end_time_;
				match valid_times with 
				| False => 
					e = build_decision_failure_event times_invalid_code;
					event e
				| True => 
					registration_end_time := registration_end_time_;
					decision_end_time := decision_end_time_;
					decision_built_ = True; 
					decision_built := decision_built_; 
					e = build_decision_success_event; 
					event e
				end 
			end 
		end 
	end 
end 		 *)


transition register()
	(* TODO implement all the various checks *)
	voter_balances[_sender] := token_to_credit_ratio;  (* TODO get token balance and multiply *) 
	e = register_success_event;
	event e
end 


(* 
    @notice: vote on the decision
    @param: options: List of option names
    @param: credtis: Credits corresponding by index to option names
*)
transition vote(options_sender: List String, credits_sender: List Int128)	
	(* TODO check if voter is allowed *) 	
	(* check if options_sender == options *)
	opt_eq = eq_string_lists options_sender options;
	(* TODO check if options.length == credits_sender.length *)
	cs_len = i128_len credits_sender;
	opt_len = s_len options;
	eq_len = uint32_eq opt_len cs_len;
	is_valid = andb eq_len opt_eq;
	match opt_eq with
	 | False =>
	  e = vote_failure_event option_invalid_code;
		event e
	 | True => 
	 (* do votin stuff *)
	  e = vote_success_event; 
		event e
	 end
end 
	


(* 
TODO 
 - vote with a list of options and a list of credits. or simply a list of credits if the order is maintained 
- quadratic voting 
*) 

