scilla_version 0 

import BoolUtils IntUtils ListUtils PairUtils


library QVote 

let zero = Uint32 0 


let vote_from_list_of_options_credits_to_map: List String -> List Int128 -> Map String Int128 -> Map String Int128 =
  fun(ls: List String) =>
    fun(lc: List Int128) => 
      fun(msi: Map String Int128) => 
        let zip = @list_zip String Int128 in
        let zipped = zip ls lc in
        let foldleft = @list_foldl (Pair String Int128) (Map String Int128) in
        let f = @fst String Int128 in
        let s = @snd String Int128 in
        let addVote =
         fun (acc : Map String Int128) =>
         fun (option_credit_pair : Pair String Int128) =>
          let opt = f option_credit_pair in
          let cred = s option_credit_pair in
          let cur_val = builtin get acc opt in
          match cur_val with
          | Some cur =>
            let new_val = builtin add cur cred in
            builtin put acc opt new_val
          | None =>
            builtin put acc opt cred
          end
         in
        foldleft addVote msi zipped
        
let pos_int128_sqrt: Int128 -> Int128 =
  fun(i: Int128) =>
    let uint = builtin to_uint128 i in
    match uint with
      | Some c =>
        let sqrt = builtin isqrt c in
        let int = builtin to_int128 sqrt in
        match int with 
        | Some cast_int =>
          cast_int
        | None =>
          Int128 0
        end
      | None =>
        Int128 0
    end

(* 
  @notice: THE RESULT NEEDS TO BE DIV BY 100 
  This is actually not exactly a sqrt function
  given an integer i
  it returns sign(i)*sqrt(abs(i))*100
*)
let int128_credit_to_vote: Int128 -> Int128 =
   fun(i : Int128) =>
    let zero = Int128 0 in
    let is_negative = int128_lt i zero in
    let ten_k = Int128 10000 in
    let mult_by_10k = builtin mul ten_k i in
    match is_negative with 
    | True => 
      let minus_one = Int128 -1 in
      let positive = builtin mul minus_one mult_by_10k in
      let res = pos_int128_sqrt positive in
      builtin mul minus_one res
    | False  =>
      pos_int128_sqrt mult_by_10k
    end

let int128_map_credits_to_votes: List Int128 -> List Int128 =
  fun(l : List Int128) =>
    let map = @list_map Int128 Int128 in
    map int128_credit_to_vote l


let int128_abs: Int128 -> Int128 = 
  fun(i : Int128) =>
    let zero = Int128 0 in
    let is_negative = int128_lt i zero in
    match is_negative with 
    | True => 
      let minus_one = Int128 -1 in
      builtin mul minus_one i
    | False  => i
    end

let in128_list_abs: List Int128 -> List Int128 = 
  fun(l : List Int128) => 
    let map = @list_map Int128 Int128 in
    map int128_abs l
    

let i128_len: List Int128 -> Uint32 = 
  fun (l : List Int128) => 
    let len = @list_length Int128 in
    len l
let s_len: List String -> Uint32 = 
  fun (l : List String) => 
    let len = @list_length String in
    len l

let eq_string: String -> String -> Bool = 
  fun(s1 : String) => 
  fun(s2 : String) =>
    builtin eq s1 s1

let eq_lr_pair: Pair String String -> Bool =
  fun(p : Pair String String) =>
    let f = @fst String String in
    let s = @snd String String in
    let l = f p in
    let r = s p in
    eq_string l r
    
let eq_string_lists: List String -> List String -> Bool = 
  fun(ls1 : List String) => 
  fun(ls2 : List String) =>
    let zip = @list_zip String String in
    let zipped = zip ls1 ls2 in
    let all = @list_forall (Pair String String) in
    all eq_lr_pair zipped
    
let int128_list_int128_sum : List Int128 -> Int128 =
   fun (l : List Int128) =>
   let foldleft = @list_foldl Int128 Int128 in
   let initState = Int128 0 in
   let addVal =
     fun (acc : Int128) =>
     fun (credits : Int128) =>
       builtin add acc credits
   in
     foldleft addVal initState l

let list_exist_string = @list_exists String 
let list_length_string = @list_length String  

let check_option_list_valid = 
	fun (option_list : List String) => 
		let l = list_length_string option_list in 
			builtin eq l zero

let check_times_valid = 
  fun(registration: BNum) => 
  fun(decision: BNum) => 
    True   (* TODO implement me please *) 

(* event codes *) 
let not_owner_code = Uint32 0

(* decision build codes *) 
let decision_already_built_code = Uint32 1
let decision_not_build_code = Uint32 2
let option_titles_invalid_code = Uint32 3
let times_invalid_code = Uint32 4
let build_decision_success_code = Uint32 5 

(* registration codes *) 
let election_started_code = Uint32 6
let zero_token_balance_code = Uint32 7
let already_registered_code = Uint32 8
let register_success_code = Uint32 9 

(* vote codes *)
let option_invalid_code = Uint32 10 
let not_registered_code = Uint32 11 
let insufficient_balance_code = Uint32 12 
let decision_ended_code = Uint32 13
let vote_success_code = Uint32 14

(* events *)
let build_decision_success_event = {_eventname: "build_decision_success"; code: build_decision_success_code}
let build_decision_failure_event =
  fun(event_code: Uint32) => 
    {_eventname: "build_decision_failure"; code: event_code}
    
let register_success_event = {_eventname: "register_success"; code: register_success_code}
let register_failure_event = 
  fun(event_code: Uint32) => 
    {_eventname: "register_failure"; code: event_code}

let vote_success_event = {_eventname: "vote_success"; code: vote_success_code}
let vote_failure_event = 
  fun(event_code: Uint32) => 
    {_eventname: "vote_failure"; code: event_code}
    


contract QVote 
(
    owner: ByStr20,
    expiration_block: BNum, (* We are going to calculate the block at which the contract expires *)
    name: String,
    description: String,
    options: List String,
    token_to_credit_ratio: Int32,
    registration_end_time: BNum
)

(* TODO do constraint checks at contract creation *)

field voter_balances : Map ByStr20 Int32 = Emp ByStr20 Int32
(* VOTES have to be div by 100 to get the actual votes since sqrt is an integer sqrt *)
field options_to_votes_map : Map String Int128 = Emp String Int128

(* transition build_decision(option_titles_:List String, registration_end_time_:BNum, decision_end_time_:BNum)
  decision_built_ <- decision_built; 
	match decision_built_ with 
	| True => 
		e = build_decision_failure_event decision_already_built_code;
		event e
	| False => 
		is_owner = builtin eq owner _sender; 
		match is_owner with 
		| False => 
			e = build_decision_failure_event not_owner_code;
			event e 
		| True => 	
			is_valid = check_option_list_valid option_titles_; 
			match is_valid with 
			| False => 
				e = build_decision_failure_event option_titles_invalid_code; 
				event e
			| True => 
				option_titles := option_titles_; 
				valid_times = check_times_valid registration_end_time_ decision_end_time_;
				match valid_times with 
				| False => 
					e = build_decision_failure_event times_invalid_code;
					event e
				| True => 
					registration_end_time := registration_end_time_;
					decision_end_time := decision_end_time_;
					decision_built_ = True; 
					decision_built := decision_built_; 
					e = build_decision_success_event; 
					event e
				end 
			end 
		end 
	end 
end 		 *)


transition register()
	(* TODO implement all the various checks *)
	voter_balances[_sender] := token_to_credit_ratio;  (* TODO get token balance and multiply *) 
	e = register_success_event;
	event e
end 


(* 
    @notice: vote on the decision
    @param: options: List of option names
    @param: credtis: Credits corresponding by index to option names
*)
(* TODO do some maths that calculates the max number of credits that can be submitted
   aka at what point List Int128 > Int256
*)
transition vote(options_sender: List String, credits_sender: List Int128)	
  (*
    TODO check if voter is registered
    if voter balance >= registered balance or something similar
    then allow
    else reject
    TODO check if voting time did not expire
  *)
	(* check if options_sender == options *)
	opt_eq = eq_string_lists options_sender options;
	(* check if options.length == credits_sender.length *)
	cs_len = i128_len credits_sender;
	opt_len = s_len options;
	eq_len = uint32_eq opt_len cs_len;
	(* for all credits_sender take absolute val *)
	abs_val_sender_credits = in128_list_abs credits_sender;
	(* get sum of abs val *)
	abs_val_sum_int128 = int128_list_int128_sum abs_val_sender_credits;
	(* TODO check if sum credits_sender <=  token_to_credit_ratio*token_balance *)
	is_valid = andb eq_len opt_eq;
	match is_valid with
	 | False =>
	  e = vote_failure_event option_invalid_code;
		event e
	 | True => 
	 (* do votin stuff *)
	  copy <- options_to_votes_map;
	  votes_sender = int128_map_credits_to_votes credits_sender;
	  new_opt_votes_map = vote_from_list_of_options_credits_to_map options_sender votes_sender copy;
	  options_to_votes_map := new_opt_votes_map;
	  e = vote_success_event; 
		event e
	 end
end 
	


(* 
TODO 
 - vote with a list of options and a list of credits. or simply a list of credits if the order is maintained 
- quadratic voting 
*) 

